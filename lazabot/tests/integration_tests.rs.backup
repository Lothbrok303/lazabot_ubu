use anyhow::Result;
use std::time::Duration;
use tokio::time::sleep;
use tracing::{info, warn};

use lazabot::api::{ApiClient, ProxyInfo};
use lazabot::proxy::{ProxyManager, ProxyHealth};
use lazabot::core::{MonitorTask, MonitorEngine, PerformanceMonitor};
use lazabot::config::load_config;

/// Test configuration for integration tests
const TEST_RETRY_DELAY: Duration = Duration::from_millis(100);

/// Test HTTP endpoints for integration testing
const TEST_HTTP_ENDPOINTS: &[&str] = &[
    "https://httpbin.org/get",
    "https://httpbin.org/status/200",
    "https://httpbin.org/headers",
];

#[tokio::test]
async fn test_api_client_basic_functionality() -> Result<()> {
    info!("Testing API client basic functionality");
    
    let client = ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?;
    
    // Test GET request
    for endpoint in TEST_HTTP_ENDPOINTS {
        info!("Testing GET request to: {}", endpoint);
        let response = client.request(
            reqwest::Method::GET,
            endpoint,
            None,
            None,
            None,
        ).await;
        
        match response {
            Ok(resp) => {
                assert!(resp.status >= 200 && resp.status < 300);
                // Check if response has content (may be empty for some endpoints)
                if !resp.text.is_empty() {
                    info!("✓ GET request to {} successful with content", endpoint);
                } else {
                    info!("✓ GET request to {} successful (empty response)", endpoint);
                }
            }
            Err(e) => {
                warn!("GET request to {} failed: {}", endpoint, e);
                // This is acceptable for integration tests as network may be unavailable
            }
        }
        
        sleep(TEST_RETRY_DELAY).await;
    }
    
    Ok(())
}

#[tokio::test]
async fn test_api_client_with_headers() -> Result<()> {
    info!("Testing API client with custom headers");
    
    let client = ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?;
    
    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert("X-Test-Header", "integration-test".parse()?);
    headers.insert("User-Agent", "Lazabot-Custom-UA/1.0".parse()?);
    
    let response = client.request(
        reqwest::Method::GET,
        "https://httpbin.org/headers",
        Some(headers),
        None,
        None,
    ).await;
    
    match response {
        Ok(resp) => {
            assert!(resp.status >= 200 && resp.status < 300);
            assert!(resp.text.contains("integration-test"));
            assert!(resp.text.contains("Lazabot-Custom-UA"));
            info!("✓ Custom headers test successful");
        }
        Err(e) => {
            warn!("Custom headers test failed: {}", e);
        }
    }
    
    Ok(())
}

#[tokio::test]
async fn test_api_client_post_request() -> Result<()> {
    info!("Testing API client POST request");
    
    let client = ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?;
    
    let test_data = r#"{"test": "data", "timestamp": "2024-01-01T00:00:00Z"}"#;
    let body = test_data.as_bytes().to_vec();
    
    let mut headers = reqwest::header::HeaderMap::new();
    headers.insert("Content-Type", "application/json".parse()?);
    
    let response = client.request(
        reqwest::Method::POST,
        "https://httpbin.org/post",
        Some(headers),
        Some(body),
        None,
    ).await;
    
    match response {
        Ok(resp) => {
            assert!(resp.status >= 200 && resp.status < 300);
            assert!(resp.text.contains("test"));
            assert!(resp.text.contains("data"));
            info!("✓ POST request test successful");
        }
        Err(e) => {
            warn!("POST request test failed: {}", e);
        }
    }
    
    Ok(())
}

#[tokio::test]
async fn test_proxy_manager_creation() -> Result<()> {
    info!("Testing proxy manager creation and basic functionality");
    
    let proxies = vec![
        ProxyInfo::new("127.0.0.1".to_string(), 8080),
        ProxyInfo::new("127.0.0.1".to_string(), 8081),
        ProxyInfo::new("8.8.8.8".to_string(), 53),
    ];
    
    let manager = ProxyManager::new(proxies);
    assert_eq!(manager.total_proxies(), 3);
    
    // Test round-robin selection
    for i in 0..5 {
        if let Some(proxy) = manager.get_next_proxy().await {
            info!("Round-robin selection {}: {}:{}", i + 1, proxy.host, proxy.port);
        } else {
            warn!("No proxy available for selection {}", i + 1);
        }
    }
    
    info!("✓ Proxy manager creation test successful");
    Ok(())
}

#[tokio::test]
async fn test_proxy_health_checker() -> Result<()> {
    info!("Testing proxy health checker");
    
    let health_checker = ProxyHealth::new()?;
    
    // Test with a proxy that will likely fail (DNS server)
    let test_proxy = ProxyInfo::new("8.8.8.8".to_string(), 53);
    let result = health_checker.check_proxy_health(&test_proxy).await;
    
    info!("Proxy health check result: {}", result);
    
    info!("✓ Proxy health checker test successful");
    Ok(())
}

#[tokio::test]
async fn test_monitor_task_creation() -> Result<()> {
    info!("Testing monitor task creation");
    
    let api_client = std::sync::Arc::new(ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?);
    let proxy_manager = std::sync::Arc::new(ProxyManager::new(vec![]));
    
    let monitor = MonitorTask::new(
        "test-product-123".to_string(),
        "https://httpbin.org/json".to_string(),
        "Test Product".to_string(),
        api_client,
        proxy_manager,
        5000, // 5 second interval
    );
    
    // Test that monitor was created successfully by checking event receiver
    let _receiver = monitor.get_event_receiver();
    
    info!("✓ Monitor task creation test successful");
    Ok(())
}

#[tokio::test]
async fn test_monitor_engine() -> Result<()> {
    info!("Testing monitor engine");
    
    let _engine = MonitorEngine::new();
    // Test that engine was created successfully
    assert!(true); // Basic creation test
    
    info!("✓ Monitor engine test successful");
    Ok(())
}

#[tokio::test]
async fn test_performance_monitor() -> Result<()> {
    info!("Testing performance monitor");
    
    let mut monitor = PerformanceMonitor::new("integration_test");
    
    // Test timing functionality
    monitor.start();
    sleep(Duration::from_millis(10)).await;
    let duration = monitor.end();
    
    assert!(duration.as_millis() >= 10);
    
    info!("✓ Performance monitor test successful");
    Ok(())
}

#[tokio::test]
async fn test_api_client_retry_mechanism() -> Result<()> {
    info!("Testing API client retry mechanism");
    
    let mut retry_config = lazabot::api::RetryConfig::default();
    retry_config.max_retries = 2;
    retry_config.base_delay_ms = 100;
    
    let client = ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?
        .with_retry_config(retry_config);
    
    // Test with a URL that will likely fail (invalid domain)
    let response = client.request(
        reqwest::Method::GET,
        "https://this-domain-should-not-exist-12345.com/get",
        None,
        None,
        None,
    ).await;
    
    // Should fail after retries
    assert!(response.is_err());
    
    info!("✓ API client retry mechanism test successful");
    Ok(())
}

#[tokio::test]
async fn test_proxy_with_authentication() -> Result<()> {
    info!("Testing proxy with authentication");
    
    let proxy = ProxyInfo::new("127.0.0.1".to_string(), 8080)
        .with_auth("testuser".to_string(), "testpass".to_string());
    
    let proxy_url = proxy.to_url()?;
    assert!(proxy_url.contains("testuser"));
    assert!(proxy_url.contains("testpass"));
    assert!(proxy_url.starts_with("http://"));
    
    info!("✓ Proxy authentication test successful");
    Ok(())
}

#[tokio::test]
async fn test_config_loading() -> Result<()> {
    info!("Testing configuration loading");
    
    // Test loading from a non-existent file (should handle gracefully)
    let result = load_config("non-existent-config.toml");
    match result {
        Ok(_) => {
            info!("Config file loaded successfully");
        }
        Err(e) => {
            warn!("Config loading failed (expected for non-existent file): {}", e);
        }
    }
    
    info!("✓ Configuration loading test successful");
    Ok(())
}

#[tokio::test]
async fn test_end_to_end_monitoring_workflow() -> Result<()> {
    info!("Testing end-to-end monitoring workflow");
    
    // Create components
    let api_client = std::sync::Arc::new(ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?);
    let proxy_manager = std::sync::Arc::new(ProxyManager::new(vec![]));
    
    // Create monitor task
    let monitor = MonitorTask::new(
        "integration-test-product".to_string(),
        "https://httpbin.org/json".to_string(),
        "Integration Test Product".to_string(),
        api_client,
        proxy_manager,
        1000, // 1 second interval for faster testing
    );
    
    // Test monitor configuration by getting event receiver
    let _receiver = monitor.get_event_receiver();
    
    info!("✓ End-to-end monitoring workflow test successful");
    Ok(())
}

#[tokio::test]
async fn test_error_handling() -> Result<()> {
    info!("Testing error handling");
    
    let client = ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?;
    
    // Test invalid URL
    let result = client.request(
        reqwest::Method::GET,
        "not-a-valid-url",
        None,
        None,
        None,
    ).await;
    assert!(result.is_err());
    
    // Test invalid proxy
    let invalid_proxy = ProxyInfo::new("invalid-host".to_string(), 9999);
    let _result = client.request(
        reqwest::Method::GET,
        "https://httpbin.org/get",
        None,
        None,
        Some(invalid_proxy),
    ).await;
    // This might succeed or fail depending on network, both are acceptable
    
    info!("✓ Error handling test successful");
    Ok(())
}

#[tokio::test]
async fn test_concurrent_requests() -> Result<()> {
    info!("Testing concurrent requests");
    
    let client = std::sync::Arc::new(ApiClient::new(Some("Lazabot-Integration-Test/1.0".to_string()))?);
    
    let mut handles = vec![];
    
    // Spawn multiple concurrent requests
    for _i in 0..5 {
        let client = client.clone();
        let handle = tokio::spawn(async move {
            client.request(
                reqwest::Method::GET,
                "https://httpbin.org/get",
                None,
                None,
                None,
            ).await
        });
        handles.push(handle);
    }
    
    // Wait for all requests to complete
    let mut success_count = 0;
    for handle in handles {
        match handle.await {
            Ok(Ok(_)) => success_count += 1,
            Ok(Err(e)) => warn!("Concurrent request failed: {}", e),
            Err(e) => warn!("Task failed: {}", e),
        }
    }
    
    info!("✓ Concurrent requests test completed ({} successful)", success_count);
    Ok(())
}

// ============================================================================
// PROXY MANAGER INTEGRATION TESTS
// ============================================================================

#[tokio::test]
async fn test_proxy_manager_file_loading() -> Result<()> {
    info!("Testing ProxyManager file loading functionality");
    
    // Create a temporary proxy file for testing
    let proxy_content = r#"
# Test proxy file
127.0.0.1:8080
192.168.1.1:3128
10.0.0.1:8080:testuser:testpass
# Invalid line should be ignored
invalid:proxy:format
# Empty line should be ignored

# Another valid proxy
203.0.113.1:1080:user2:pass2
"#;
    
    let temp_file = "test_proxies_temp.txt";
    tokio::fs::write(temp_file, proxy_content).await?;
    
    // Test loading from file
    let manager = ProxyManager::from_file(temp_file).await?;
    
    // Verify loaded proxies
    assert_eq!(manager.total_proxies(), 4);
    
    let all_proxies = manager.get_all_proxies();
    assert_eq!(all_proxies.len(), 4);
    
    // Check first proxy (no auth)
    assert_eq!(all_proxies[0].host, "127.0.0.1");
    assert_eq!(all_proxies[0].port, 8080);
    assert!(all_proxies[0].username.is_none());
    
    // Check third proxy (with auth)
    assert_eq!(all_proxies[2].host, "10.0.0.1");
    assert_eq!(all_proxies[2].port, 8080);
    assert_eq!(all_proxies[2].username, Some("testuser".to_string()));
    assert_eq!(all_proxies[2].password, Some("testpass".to_string()));
    
    // Clean up
    tokio::fs::remove_file(temp_file).await?;
    
    info!("✓ ProxyManager file loading test completed");
    Ok(())
}

#[tokio::test]
async fn test_proxy_manager_round_robin() -> Result<()> {
    info!("Testing ProxyManager round-robin selection");
    
    let proxies = vec![
        ProxyInfo::new("127.0.0.1".to_string(), 8080),
        ProxyInfo::new("192.168.1.1".to_string(), 3128),
        ProxyInfo::new("10.0.0.1".to_string(), 1080),
    ];
    
    let manager = ProxyManager::new(proxies);
    
    // Test round-robin selection
    let mut selected_proxies = Vec::new();
    for _ in 0..6 { // Test 2 full cycles
        if let Some(proxy) = manager.get_next_proxy().await {
            selected_proxies.push(proxy);
        }
    }
    
    // Verify round-robin pattern
    assert_eq!(selected_proxies.len(), 6);
    assert_eq!(selected_proxies[0].host, "127.0.0.1");
    assert_eq!(selected_proxies[1].host, "192.168.1.1");
    assert_eq!(selected_proxies[2].host, "10.0.0.1");
    assert_eq!(selected_proxies[3].host, "127.0.0.1"); // Second cycle
    assert_eq!(selected_proxies[4].host, "192.168.1.1");
    assert_eq!(selected_proxies[5].host, "10.0.0.1");
    
    info!("✓ ProxyManager round-robin test completed");
    Ok(())
}

#[tokio::test]
async fn test_proxy_manager_health_tracking() -> Result<()> {
    info!("Testing ProxyManager health tracking functionality");
    
    let proxies = vec![
        ProxyInfo::new("127.0.0.1".to_string(), 8080),
        ProxyInfo::new("192.168.1.1".to_string(), 3128),
        ProxyInfo::new("10.0.0.1".to_string(), 1080),
    ];
    
    let manager = ProxyManager::new(proxies);
    
    // Initially all proxies should be healthy
    assert_eq!(manager.healthy_proxies_count().await, 3);
    
    // Mark first proxy as unhealthy
    let proxy1 = &manager.get_all_proxies()[0];
    manager.set_proxy_health(proxy1, false).await;
    
    // Verify health status
    assert_eq!(manager.healthy_proxies_count().await, 2);
    assert!(!manager.is_proxy_healthy(proxy1).await);
    
    // Get healthy proxies should exclude the unhealthy one
    let healthy_proxies = manager.get_healthy_proxies().await;
    assert_eq!(healthy_proxies.len(), 2);
    assert!(!healthy_proxies.iter().any(|p| p.host == "127.0.0.1"));
    
    // Round-robin should skip unhealthy proxies
    let mut selected_proxies = Vec::new();
    for _ in 0..4 {
        if let Some(proxy) = manager.get_next_proxy().await {
            selected_proxies.push(proxy);
        }
    }
    
    // Should only get healthy proxies
    assert_eq!(selected_proxies.len(), 4);
    assert!(!selected_proxies.iter().any(|p| p.host == "127.0.0.1"));
    
    // Reset all health
    manager.reset_all_health().await;
    assert_eq!(manager.healthy_proxies_count().await, 3);
    
    info!("✓ ProxyManager health tracking test completed");
    Ok(())
}

#[tokio::test]
async fn test_proxy_manager_edge_cases() -> Result<()> {
    info!("Testing ProxyManager edge cases");
    
    // Test empty proxy list
    let empty_manager = ProxyManager::new(vec![]);
    assert_eq!(empty_manager.total_proxies(), 0);
    assert!(empty_manager.get_next_proxy().await.is_none());
    assert_eq!(empty_manager.healthy_proxies_count().await, 0);
    
    // Test single proxy
    let single_proxy = vec![ProxyInfo::new("127.0.0.1".to_string(), 8080)];
    let single_manager = ProxyManager::new(single_proxy);
    
    // Should always return the same proxy
    for _ in 0..3 {
        let proxy = single_manager.get_next_proxy().await.unwrap();
        assert_eq!(proxy.host, "127.0.0.1");
        assert_eq!(proxy.port, 8080);
    }
    
    // Test all proxies unhealthy
    let proxies = vec![
        ProxyInfo::new("127.0.0.1".to_string(), 8080),
        ProxyInfo::new("192.168.1.1".to_string(), 3128),
    ];
    let manager = ProxyManager::new(proxies);
    
    // Mark all proxies as unhealthy
    for proxy in manager.get_all_proxies() {
        manager.set_proxy_health(proxy, false).await;
    }
    
    // Should return None when all proxies are unhealthy
    assert!(manager.get_next_proxy().await.is_none());
    assert_eq!(manager.healthy_proxies_count().await, 0);
    
    info!("✓ ProxyManager edge cases test completed");
    Ok(())
}

// ============================================================================
// TASK MANAGER INTEGRATION TESTS
// ============================================================================

/// Test task implementation for integration tests
struct TestTask {
    name: String,
    duration_ms: u64,
    should_fail: bool,
    result_data: Option<serde_json::Value>,
}

impl TestTask {
    fn new(name: impl Into<String>, duration_ms: u64) -> Self {
        Self {
            name: name.into(),
            duration_ms,
            should_fail: false,
            result_data: None,
        }
    }
    
    fn with_failure(mut self) -> Self {
        self.should_fail = true;
        self
    }
    
    fn with_result(mut self, data: serde_json::Value) -> Self {
        self.result_data = Some(data);
        self
    }
}

#[async_trait::async_trait]
impl lazabot::tasks::Task for TestTask {
    async fn execute(&self) -> Result<serde_json::Value> {
        sleep(Duration::from_millis(self.duration_ms)).await;
        
        if self.should_fail {
            Err(anyhow::anyhow!("Task '{}' failed intentionally", self.name))
        } else {
            let result = self.result_data.clone().unwrap_or_else(|| {
                serde_json::json!({
                    "task_name": self.name,
                    "duration_ms": self.duration_ms,
                    "timestamp": chrono::Utc::now().to_rfc3339()
                })
            });
            Ok(result)
        }
    }
    
    fn name(&self) -> &str {
        &self.name
    }
}

#[tokio::test]
async fn test_task_manager_basic_operations() -> Result<()> {
    info!("Testing TaskManager basic operations");
    
    let manager = lazabot::tasks::TaskManager::new(3);
    
    // Submit a simple task
    let task = TestTask::new("basic_task", 100);
    let task_id = manager.submit_task(task).await?;
    
    assert_eq!(task_id, 0);
    assert_eq!(manager.total_tasks(), 1);
    assert_eq!(manager.pending_tasks_count(), 1);
    
    // Wait for task to complete
    sleep(Duration::from_millis(200)).await;
    
    // Check task result
    let result = manager.get_task_result(task_id).unwrap();
    assert_eq!(result.status, lazabot::tasks::TaskStatus::Completed);
    assert!(result.started_at.is_some());
    assert!(result.completed_at.is_some());
    assert!(result.error_message.is_none());
    assert!(result.metadata.is_some());
    
    info!("✓ TaskManager basic operations test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_concurrency_control() -> Result<()> {
    info!("Testing TaskManager concurrency control");
    
    let max_concurrent = 2;
    let manager = std::sync::Arc::new(lazabot::tasks::TaskManager::new(max_concurrent));
    
    // Submit more tasks than the concurrency limit
    let mut task_ids = Vec::new();
    for i in 0..5 {
        let task = TestTask::new(format!("concurrent_task_{}", i), 300);
        let task_id = manager.submit_task(task).await?;
        task_ids.push(task_id);
    }
    
    // Wait a bit for tasks to start
    sleep(Duration::from_millis(50)).await;
    
    // Check that only max_concurrent tasks are running
    let running_count = manager.running_tasks_count();
    assert!(running_count <= max_concurrent);
    
    // Wait for all tasks to complete
    sleep(Duration::from_millis(800)).await;
    
    // Verify all tasks completed
    let completed_count = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Completed).len();
    assert_eq!(completed_count, 5);
    
    info!("✓ TaskManager concurrency control test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_failed_tasks() -> Result<()> {
    info!("Testing TaskManager failed task handling");
    
    let manager = lazabot::tasks::TaskManager::new(3);
    
    // Submit a task that will fail
    let failing_task = TestTask::new("failing_task", 100).with_failure();
    let task_id = manager.submit_task(failing_task).await?;
    
    // Wait for task to complete
    sleep(Duration::from_millis(200)).await;
    
    // Check task result
    let result = manager.get_task_result(task_id).unwrap();
    assert_eq!(result.status, lazabot::tasks::TaskStatus::Failed);
    assert!(result.error_message.is_some());
    assert!(result.completed_at.is_some());
    
    // Check status counts
    let failed_count = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Failed).len();
    assert_eq!(failed_count, 1);
    
    info!("✓ TaskManager failed tasks test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_shutdown_behavior() -> Result<()> {
    info!("Testing TaskManager shutdown behavior");
    
    let manager = std::sync::Arc::new(lazabot::tasks::TaskManager::new(2));
    
    // Submit some long-running tasks
    for i in 0..3 {
        let task = TestTask::new(format!("long_task_{}", i), 500);
        manager.submit_task(task).await?;
    }
    
    // Wait a bit for tasks to start
    sleep(Duration::from_millis(100)).await;
    
    // Verify some tasks are running
    let running_count = manager.running_tasks_count();
    assert!(running_count > 0);
    
    // Initiate shutdown
    manager.shutdown().await;
    
    // Verify shutdown flag is set
    assert!(manager.is_shutting_down());
    
    // Verify we can't submit new tasks
    let new_task = TestTask::new("late_task", 100);
    let result = manager.submit_task(new_task).await;
    assert!(result.is_err());
    
    info!("✓ TaskManager shutdown behavior test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_status_queries() -> Result<()> {
    info!("Testing TaskManager status query functionality");
    
    let manager = lazabot::tasks::TaskManager::new(3);
    
    // Submit a mix of tasks
    let tasks = vec![
        TestTask::new("task1", 100),
        TestTask::new("task2", 150),
        TestTask::new("failing_task", 100).with_failure(),
        TestTask::new("task4", 200),
    ];
    
    let mut task_ids = Vec::new();
    for task in tasks {
        let task_id = manager.submit_task(task).await?;
        task_ids.push(task_id);
    }
    
    // Wait for all tasks to complete
    sleep(Duration::from_millis(800)).await;
    
    // Test status queries
    let completed = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Completed);
    let failed = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Failed);
    let pending = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Pending);
    let running = manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Running);
    
    assert_eq!(completed.len(), 3);
    assert_eq!(failed.len(), 1);
    assert_eq!(pending.len(), 0);
    assert_eq!(running.len(), 0);
    assert_eq!(manager.total_tasks(), 4);
    
    // Test getting all results
    let all_results = manager.get_all_task_results();
    assert_eq!(all_results.len(), 4);
    
    info!("✓ TaskManager status queries test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_metadata_handling() -> Result<()> {
    info!("Testing TaskManager metadata handling");
    
    let manager = lazabot::tasks::TaskManager::new(2);
    
    // Submit task with custom metadata
    let custom_data = serde_json::json!({
        "custom_field": "test_value",
        "number": 42,
        "nested": {
            "key": "value"
        }
    });
    
    let task = TestTask::new("metadata_task", 100).with_result(custom_data.clone());
    let task_id = manager.submit_task(task).await?;
    
    // Wait for task to complete
    sleep(Duration::from_millis(200)).await;
    
    // Check metadata
    let result = manager.get_task_result(task_id).unwrap();
    assert_eq!(result.status, lazabot::tasks::TaskStatus::Completed);
    assert_eq!(result.metadata, Some(custom_data));
    
    info!("✓ TaskManager metadata handling test completed");
    Ok(())
}

#[tokio::test]
async fn test_task_manager_edge_cases() -> Result<()> {
    info!("Testing TaskManager edge cases");
    
    // Test with zero concurrency limit
    let manager = lazabot::tasks::TaskManager::new(0);
    assert_eq!(manager.max_concurrent(), 0);
    assert_eq!(manager.available_permits(), 0);
    
    // Test task submission with zero concurrency
    let task = TestTask::new("zero_concurrency_task", 100);
    let result = manager.submit_task(task).await;
    // This should still work but may have different behavior
    if result.is_ok() {
        let task_id = result.unwrap();
        sleep(Duration::from_millis(200)).await;
        let task_result = manager.get_task_result(task_id).unwrap();
        // Task should either complete or be cancelled
        assert!(matches!(task_result.status,
            lazabot::tasks::TaskStatus::Completed |
            lazabot::tasks::TaskStatus::Pending |
            lazabot::tasks::TaskStatus::Cancelled |
            lazabot::tasks::TaskStatus::Failed));
    }
    
    info!("✓ TaskManager edge cases test completed");
    Ok(())
}

// ============================================================================
// MANAGER INTEGRATION TESTS
// ============================================================================

#[tokio::test]
async fn test_managers_integration() -> Result<()> {
    info!("Testing ProxyManager and TaskManager integration");
    
    // Create managers
    let proxy_manager = std::sync::Arc::new(ProxyManager::new(vec![
        ProxyInfo::new("127.0.0.1".to_string(), 8080),
        ProxyInfo::new("192.168.1.1".to_string(), 3128),
    ]));
    
    let task_manager = std::sync::Arc::new(lazabot::tasks::TaskManager::new(3));
    
    // Create a task that uses proxy manager
    struct ProxyUsingTask {
        name: String,
        proxy_manager: std::sync::Arc<ProxyManager>,
    }
    
    #[async_trait::async_trait]
    impl lazabot::tasks::Task for ProxyUsingTask {
        async fn execute(&self) -> Result<serde_json::Value> {
            // Simulate getting a proxy
            let proxy = self.proxy_manager.get_next_proxy().await;
            
            Ok(serde_json::json!({
                "task_name": self.name,
                "proxy_used": proxy.map(|p| format!("{}:{}", p.host, p.port)),
                "timestamp": chrono::Utc::now().to_rfc3339()
            }))
        }
        
        fn name(&self) -> &str {
            &self.name
        }
    }
    
    // Submit tasks that use proxy manager
    for i in 0..5 {
        let task = ProxyUsingTask {
            name: format!("proxy_task_{}", i),
            proxy_manager: proxy_manager.clone(),
        };
        task_manager.submit_task(task).await?;
    }
    
    // Wait for all tasks to complete
    sleep(Duration::from_millis(200)).await;
    
    // Verify all tasks completed
    let completed_count = task_manager.get_tasks_by_status(lazabot::tasks::TaskStatus::Completed).len();
    assert_eq!(completed_count, 5);
    
    // Verify proxy distribution (should be round-robin)
    let results = task_manager.get_all_task_results();
    let mut proxy_usage = std::collections::HashMap::new();
    
    for result in results {
        if let Some(metadata) = result.metadata {
            if let Some(proxy_used) = metadata.get("proxy_used").and_then(|v| v.as_str()) {
                *proxy_usage.entry(proxy_used.to_string()).or_insert(0) += 1;
            }
        }
    }
    
    // Should have used both proxies
    assert_eq!(proxy_usage.len(), 2);
    assert!(proxy_usage.contains_key("127.0.0.1:8080"));
    assert!(proxy_usage.contains_key("192.168.1.1:3128"));
    
    info!("✓ Managers integration test completed");
    Ok(())
}

